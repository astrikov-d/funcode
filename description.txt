Ответы на вопросы:

1. В чем отличие (i for i in arr) от [i for i in arr]?

Первый пример возвращает генератор, который выполняется лениво.
Второй пример возвращает уже готовый список.

2. Есть следующая функция:

   def myappend(a = [], num = 0):
       a.append(num)
       print a

   Что будет происходить при выполнении следующего кода и почему:

   >>> a = [1,2,3]
   >>> myappend(a)
   >>> myappend()
   >>> myappend()

   Дело в иммутабельности/мутабельности типов. Дефолтные значения аргументов функции "вычисляются" один раз - при
   обозначении функции. Дальше только модифицируются. При использовании мутабельного типа в кач-ве дефолтного значения
   аргумента функции, это значение будет изменено при каждом последующем вызове функции:

   >>> myappend()
   Дефолтное значение аргумента а = пустой список. Добавляется 0. Значение теперь [0]

   >>> myappend()
   Дефолтное значение аргумента а = [0]. Добавляется 0. Значение теперь [0, 0]

   В общем использовать мутабельные типы в качестве значений по умолчанию - это плохо.

3. Что такое декораторы? Для чего они нужны?

   Декораторы это своеобразные обертки вокруг функции. Они с одной стороны могут модифицировать args и kwargs
   оборачиваемой функции или метода, с другой - каким-то образом модифицировать возвращаемйе функцией или методом
   результат. Запрашиваемый декоратор реализован в app/decorators.py

4. Последнее задание (про itertools) честно подсмотрел на stackoverfow, т.к. в реальной жизни с таким сталкиваться
   практически никогда не приходится. Считаю, что 80% работы программиста - поиск инфорации, и в том, чтобы
   обратиться к документации/stackoverflow нет ничего плохого, даже наоборот.